      ___    _   _   _____   ___                
     / __\  | | | | |_   _| / __/               
     | |__  | |_| |  _| |_  \__ \               
     \___/   \___/  |_____| /___/               

bitwise operators:
& | << >> 

logical operators:
&& || ! 
logical operators will short circuit(if 1st fills parameter skips others)


1. edit  .java
2. compile javac -> .class
3. load .class library .class
4. verify validate + security
5. interpret  converts to machine code

JDK-java development kit: language library, and include the compiler
	compiler is javac
	compiler is part of the JDK, if problems, it is with the JDK
	editing and compiling in java (steps 1-2)
	(command line) javac file.java //creates a .class file
	.class file is in bytecode (can be ran on different OS)

JRE-java runtime environment: java virtual machine, or VM
	allows us to run a java program
	if a java file can't be run, there is a problem with the JRE
	load verify interpret (steps 3-5)
	(command line) java file

java made it big because you can compile it once and run it anywhere
because of its bytecode property, and the emergence of the internet,
java became a big deal because of different OS and doing server side
things


java -cp ./src (file path to the text file)


conventions:
	Naming
		cannot use reserved words (ie. return, instanceof, public)
		reserved words are all lower-case
		cannot use identifiers
		things that the developer controls/creates
			can have letter, numbers, $_
			cannot have spaces, and can't start with a number

packages:
	names are all lowercase, no spaces
	fist line is package statement
	used to get rid of ambiguity among classes
	use reverse domain names in order to avoid redundance
	//edu.usu.cs.man.shape.circle

	java.lang is a special package, doesn't need to be imported
		basically the standard library for java

	import packages (1st)
		type:
		import javafx.scene.control.Button; //know it isn't a
		//package because Button is capitalized
		or:
		import javafx.scene.control.* //imports all
			-not a good idea, pulls too much
			-vague doesn't inform you/other coders

	import statements (2nd)

modifiers: 
	1. public, private*, nothing
	2. abstract
	3. static*: inner class only, no instances can be made
	4. final
	5. strictfp

	filename and top level public class name are the same

	access
		private- 
		protected-
		public-
		package private- default in java
	other
		abstract- must be overridden
		final- cannot change -> constant //applies to classes
		static- belongs to class, not the instance

	must have one top level public class
		top level is, code touches left side of text-area

	classes and objects: class defines it, object is in use
		naming:
			UpperCamelCase
			nouns
			simple and descriptive
			same as interfaces

		helps with code reuse
		encapsulation
		everything is in a class, save import and package lines
		structure:

			<modifiers> class <ClassName> {

			}

	in order to restrict access to the class we have made, and
	prevent others from instantiating it as an object, you must
	override the default constructor as a private class

data:
	primitive-
		integral:
			int- 32 bit
			long- 64 bit
			short- 16 bit
			byte- 8 bit
		floating points:
			float- 32 bit
			double- 64 bit
		text:
			char- 16 bit, 
		logical:
			boolean- 1 bit, true/false
		MODIFIERS FOR PRIMITIVE:
			all access
			static
			final
	references- not pointers
		java has garbage collection done to free allocate mmry
	naming:
		lowerCamelCase
		don't start with a $,_
		mnemonic 
		no one-character identifiers (names), except i, j

	constants:
		final- to declare an unalterable variable
			naming: ALL IN CAPS

a reference and a pointer are not the same
	a pointer can do iterations and arithmetic

can access itself by saying this.<class member variable>
	can help reduce confusion between variables

methods:
	MODIFIERS: public, private, protected, static, abstract, final, 
		package protected
	FORMAL PARAMETERS: 
		formal parameters- when it is declared in the method
		actual parameters- when the method is actually called

	<MODIFIERS> <RETURN TYPE> <METHOD NAME> {
		<FORMAL PARAMETERS>

	}

String- part of java.lang (use without importing)
	declare with:
		String str1 = "hello";
		String str2 = new String("goodbye");

	printf: look up javadoc for printf to understand formatting
	parsing numbers: 
		Integer.parseInt(str1) //will convert a str to an int
			because Integer starts with "I" it is a class
			parseInt is static because we used w/o declaring instance
			Integer is a wrapper class
				8 for each of the primitive data types
	Mutable vs. immutable: Can/Can't be changed
		Strings are mutable

	Methods:
		str1.CompareTo(str2); // returns 0 if equal
		str1.equals(str2); // returns true/false
		
Input/Output:
	command line
	must always validate input(make sure it is desired size/type)

	//in order to read input from command line
	//example class for input to the scanner

	import java.util.Scanner

	public class Demo(){
		private Scanner scan = new Scanner(System.in);

		public Demo(){
			System.out.print("Enter a word: ");
			String tmpWord = scan.next();
			System.out.println("You entered: " + tmpWord);

			System.out.print("Enter a number: ");
			int tmpInt = scan.nextInt();
			System.out.println("You entered: " + tmpInt);
		}

		public static void main(String[] args){
			new Demo();
		}
	}
	
	File I/O:
	private static final String path = "data/file.txt"

	private void fileRead(){
		Scanner fileInput = null;

		try {
			fileInput = new Scanner(new FileReader(filename));
		} catch (FileNotFoundException e){
			e.printStackTrace();
		}
		while(fileInput.hasNext()){
			System.out.println(fileInput.nextLine()); //can print fileInput.next()
			//has other method within scanner, useDelimiter(Pattern or string)
			//can use regular expressions for Patterns
		}
		fileInput.close()

		private void fileWrite(){
			PrintWriter fileOutput = null;

			try {
				fileOutput = new PrintWriter(new FileOutputStream(fileName));
			} catch (FileNotFoundException e) {
				e.printStackTrace();
			}
			FileOutputStream(file, append boolean); // file path, append(will append not copy over)
		}
	}
	//check out the difference between buffer reader and file reader.
	//check out RandamAccessFile