
tansistors are just switches. built on a silicon wafer

all software has to run on hardware, find out which is faster

depending on the cpu, it will be able to handle different things:
	MIPS: 130 instructions
	x86, x64: 1400 instructions
	ARM: 255 instructions

hard to determine fastest computer, depends on what your goal is

How much faster?? take the faster and divide by slower. Gives you 
the ratio

Latency: time from input to corresponding output

Throughput: Results produced per unit time

on the CPU it will first look at the cache to see if the necessary
software is there, then it will check the RAM and finally the hard-
drive. The more it checks, the longer it takes and the less efficient
it is.

seconds/program = cycles/program * seconds/cycle

there will be an average cycles per instruction("CPI")
	not all cycles will take the same amount of time

CPU time = Instruction Count * CPI * Clock Cycle Time
MIPS: millions of Instructions per Seconds

improve performance:
	decrease required cycles for a program
	decrease the clock cycle time
	increase the clock rate
	decrease the CPI (average clocks per instruction)

Amdahl's Law:  t(improved) = t(affected)/r(speedup)+t(unaffected)

Jan. 19, 2018

multi-threading, multi-core
	rather than increasing Ghz, they will parallelise the core
		-language Rust is very multi-core oriented
	performance is a very task-specific thing

Computers only understand bits, 1's and 0's
	Nothing but a bunch of gates/switches
	fixed length: everything uses the same number of bits
		ASCII-American Standard Computer Information Interchange
			-originally it was 7-bits
			-now 8-bit ASCII
			2^7 = 128
			2^8 = 256
			2^10 = 1024
			2^20 = 1 Mega
			2^30 = 1 Giga
		to get the number of necessary bits for data types:
			log base 2 (number of symbols represented)
				round the final answer up. 
	Variable length: length changes, when the number of bits matter
		not very useful unless bandwith is limited(shuttle comms)
	Unicode: base 8 bits are ASCII, but has 16 bits overall
		has extended to using a 32-bit infrastructure
			yes these new items even include emojis
	Encoding positive numbers
		given the number 456, break each number to 10^0, 
		10^1, 10^2
		basically for each 1 in the binary, add 2^(index)
		octal is base eight
			uses 3 bits per character
		hexadecimal is base 16
			always leads with 0x.
	Negative values:
		can have sign bit, where farthest left is sign of int
		2's compliment-used to make the math much easier
			left most bit will be a negative value, the rest are (+)
			the CPU interprets it based on the instructions it is given
				can interpret 2's compliment, ascii, hexadecimal

			11+101 = 1000

			subtraction will convert one number into 2's compliment and 
			add the two numbers together

			writing 247 in binary: for unsigned bit
				keep dividing 247 by 2, 
					if(x%2 == 0) 0:1;
					x is then rounded down(if it didn't go in evenly)
			working with 2's compliment:
				using an 8-bit number, min=-128 max=127
				1. take absolute value, convert to binary

				(if negative do steps 2,3)
				2. flip all bits
					10011010 -> 01100101
				3. add one
					101100101

		
	hexadecimal and octet are basically simplified binary