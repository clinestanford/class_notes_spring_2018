
tansistors are just switches. built on a silicon wafer

all software has to run on hardware, find out which is faster

depending on the cpu, it will be able to handle different things:
	MIPS: 130 instructions
	x86, x64: 1400 instructions
	ARM: 255 instructions

hard to determine fastest computer, depends on what your goal is

How much faster?? take the faster and divide by slower. Gives you 
the ratio

Latency: time from input to corresponding output

Throughput: Results produced per unit time

on the CPU it will first look at the cache to see if the necessary
software is there, then it will check the RAM and finally the hard-
drive. The more it checks, the longer it takes and the less efficient
it is.

seconds/program = cycles/program * seconds/cycle

there will be an average cycles per instruction("CPI")
	not all cycles will take the same amount of time

CPU time = Instruction Count * CPI * Clock Cycle Time
MIPS: millions of Instructions per Seconds

improve performance:
	decrease required cycles for a program
	decrease the clock cycle time
	increase the clock rate
	decrease the CPI (average clocks per instruction)

Amdahl's Law:  t(improved) = t(affected)/r(speedup)+t(unaffected)

Jan. 19, 2018

multi-threading, multi-core
	rather than increasing Ghz, they will parallelise the core
		-language Rust is very multi-core oriented
	performance is a very task-specific thing

Computers only understand bits, 1's and 0's
	Nothing but a bunch of gates/switches
	fixed length: everything uses the same number of bits
		ASCII-American Standard Computer Information Interchange
			-originally it was 7-bits
			-now 8-bit ASCII
			2^7 = 128
			2^8 = 256
			2^10 = 1024
			2^20 = 1 Mega
			2^30 = 1 Giga
		to get the number of necessary bits for data types:
			log base 2 (number of symbols represented)
				round the final answer up. 
	Variable length: length changes, when the number of bits matter
		not very useful unless bandwith is limited(shuttle comms)
	Unicode: base 8 bits are ASCII, but has 16 bits overall
		has extended to using a 32-bit infrastructure
			yes these new items even include emojis
	Encoding positive numbers
		given the number 456, break each number to 10^0, 
		10^1, 10^2
		basically for each 1 in the binary, add 2^(index)
		octal is base eight
			uses 3 bits per character
		hexadecimal is base 16
			always leads with 0x.
	Negative values:
		2's compliment-used to make the math much easier
		

